{% from 'tools.j2' import render_docstring %}
{% from 'method.j2' import render_method %}

{% macro render_class(cls) -%}

{%- if not cls.base_class -%}
class {{ cls.name | fix_name }}(BaseObject):
{%- else -%}
class {{ cls.name | fix_name }}({{ cls.base_class | fix_name }}):
{%- endif %}
    {{ render_docstring(cls.name) | indent(width=4) }}
    __is_godot_native_class = True
    __slots__ = ()
    _gd_name = "{{ cls.name }}"
    _gd_constructor = ClassDB.get_class_constructor("{{ cls.name }}")

    def _gd_constructor(self):
        gd_classname = godot_string_from_pyobj("{{ cls.name }}")
        # TODO: alloc this on the stack (using _malloca ?)
        args = ffi.new("void*[]", [gd_classname])
        ret = godot_variant_alloc()
        lib.godot_method_bind_ptrcall(_meth_instance, _instance, args, ret)
        objret = lib.godot_variant_as_object(ret)
        # Quick'n dirty fix to prevent Ressource objects from beeing automatically
        # freed when the variant is destroyed given it holds the only ref on it
        self._gd_var = ret
        return objret

{%- for constant_name, constant_value in cls.constants.items() -%}
{%- if not constant_is_enum(cls.enums, constant_name) %}
    {{ render_docstring(cls.name + '.' + constant_name) | indent(width=4) }}
    {{ constant_name | fix_name }} = {{ constant_value }}
{%- endif -%}
{%- endfor -%}

{%- for enum in cls.enums -%}
    {{ render_docstring(cls.name + '.' + enum.name) | indent(width=4) }}
    class {{ enum.name | fix_name }}(Enum):
{%- for enum_entry_name, enum_entry_value in enum['values'].items() %}
        {{ render_docstring(cls.name + '.' + enum.name + '.' + enum_entry_name) | indent(width=4) }}
        {{ enum_entry_name }} = {{ enum_entry_value }}
{%- endfor -%}
{%- endfor -%}

{%- for signal in cls.signals -%}
    {{ render_docstring(cls.name + '.' + signal.name) | indent(width=4) }}
    # Signal {{ signal.name | fix_name }}
{%- endfor -%}

{%- for prop in cls.properties %}
{%- set prop_name = prop.name | fix_name %}

    @property
    def {{ prop_name }}(self):
        {{ render_docstring(cls.name + '.' + prop.name) | indent(width=8) }}
        gd_propname = godot_string_from_pyobj("{{ prop.name }}")
        ret = godot_variant_alloc()
        lib.godot_variant_new_nil(ret)
        args = ffi.new("void*[]", [self._gd_ptr, gd_propname])
        lib.godot_method_bind_ptrcall(
            _meth_get_property, _instance, args, ret
        )
        return variant_to_pyobj(ret)

    @{{ prop_name }}.setter
    def {{ prop_name }}(self, value):
        gd_propname = godot_string_from_pyobj("{{ prop.name }}")
        gd_value = pyobj_to_variant(value)
        args = ffi.new("void*[]", [self._gd_ptr, gd_propname, gd_value])
        ret = godot_variant_alloc()
        lib.godot_variant_new_nil(ret)
        lib.godot_method_bind_ptrcall(
            _meth_set_property, _instance, args, ret
        )
        return variant_to_pyobj(ret)
{%- endfor %}

{% for method in cls.methods -%}
    {{ render_method(cls, method) | indent(width=4) }}
{% endfor -%}

{%- if not cls.constants and not cls.signals and not cls.members and not cls.methods %}
    pass
{%- endif -%}

{%- endmacro %}
