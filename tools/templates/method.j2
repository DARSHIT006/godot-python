{% from 'tools.j2' import render_docstring, render_call_args %}

{% macro render_method(cls, method) %}
def {{ method.name | fix_name }}({{ render_call_args(method.args) }}
{%- if method.has_varargs -%}
, *args
{%- endif -%}
):
    {{ render_docstring(cls.name + '.' + method.name) | indent(width=4) }}
{%- if method.is_virtual -%}

    raise NotImplementedError("Method {{ cls.name | fix_name }}.{{ method.name | fix_name }} is virtual")

{%- elif method.has_varargs -%}

    # Vararg methods are not supported by ptrcall, must use slower dynamic mode instead
    fixargs_count = len(meth["args"])

    vaargs = [
        convert_arg(meth_arg["type"], meth_arg["name"], arg, to_variant=True)
        for arg, meth_arg in zip(args, meth["args"])
    ]
    vaargs += [pyobj_to_variant(arg) for arg in args[fixargs_count:]]
    vavaargs = ffi.new("godot_variant*[]", vaargs) if vaargs else ffi.NULL
    # TODO: use `godot_variant_call_error` to raise exceptions
    varret = lib.godot_method_bind_call(
        methbind, self._gd_ptr, vavaargs, len(args), ffi.NULL
    )
    ret = variant_to_pyobj(ffi.addressof(varret))
    return ret

{%- else -%}

    # TODO: allow **kwargs
    # check number of args
    n_args, nm_args, nmd_args = len(args), len(meth["args"]), len(
        meth["default_args"]
    )
    nr_args = nm_args - nmd_args  # number of required arguments
    if n_args < nr_args:  # not enough args, raise error
        if nr_args - n_args == 1:
            raise TypeError(
                "%s() missing 1 required positional argument: '%s'"
                % (methname, meth["args"][nr_args - 1]["name"])
            )

        else:
            raise TypeError(
                "%s() missing %i required positional arguments: "
                % (methname, nr_args - n_args)
                + ", ".join(
                    "'%s'" % (arg["name"])
                    for arg in meth["args"][n_args:nr_args - 1]
                )
                + " and '%s'"
                % (meth["args"][nr_args - 1]["name"])
            )

    if n_args > nm_args:  # too many args, raise error
        if nmd_args == 0:
            raise TypeError(
                "%s() takes %i positional argument%s but %i were given"
                % (methname, nm_args, "s" if nm_args > 1 else "", n_args)
            )

        else:
            raise TypeError(
                "%s() takes from %i to %i positional arguments but %i were given"
                % (methname, nr_args, nm_args, n_args)
            )

    # complete missing optional args with default values
    diff = len(args) - len(meth["args"])
    args += meth["default_args"][diff:]

    # TODO: check args type here (ptrcall means segfault on bad args...)
    raw_args = [
        convert_arg(meth_arg["type"], meth_arg["name"], arg)
        for arg, meth_arg in zip(args, meth["args"])
    ]
    gdargs = ffi.new("void*[]", raw_args) if raw_args else ffi.NULL
    ret = new_uninitialized_gdobj(rettype)
    lib.godot_method_bind_ptrcall(methbind, self._gd_ptr, gdargs, ret)
    ret = gdobj_to_pyobj(rettype, ret)
    return ret

{%- endif -%}
{%- endmacro %}
