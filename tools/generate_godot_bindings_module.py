#! /usr/bin/env python3

import keyword
import xmltodict
import argparse
import pathlib
import jinja2
import black


TEMPLATE = jinja2.Template(
    r'''
# AUTOGENERATED by tools/generate_godot_bindings_module.py

from pythonscriptcffi import ffi, lib

# Republishing builtins
from godot.vector2 import Vector2
from godot.rect2 import Rect2
from godot.vector3 import Vector3
from godot.transform2d import Transform2D
from godot.plane import Plane
from godot.quat import Quat
from godot.aabb import AABB
from godot.basis import Basis
from godot.transform import Transform
from godot.color import Color
from godot.node_path import NodePath
from godot.rid import RID
from godot.dictionary import Dictionary
from godot.array import Array
from godot.pool_arrays import (
    PoolByteArray,
    PoolIntArray,
    PoolRealArray,
    PoolStringArray,
    PoolVector2Array,
    PoolVector3Array,
    PoolColorArray,
)


__GODOT_API_VERSION__ = '{{ godot_api_version }}'


{%- macro gen_docstring(txt) -%}
{%- if txt and not NO_DOCSTRINGS -%}
"""
{{ txt | wordwrap }}
"""
{%- endif -%}
{%- endmacro -%}

{%- macro gen_call_args(args) -%}
self
{%- for arg in args -%}
, {{ arg.name }}
{%- endfor -%}
{% endmacro -%}

{% for cls in classes %}


class {{ cls.name }}:
    {{ gen_docstring(cls.doc) | indent(width=4) }}

{%- for constant in cls.constants %}

    {{ gen_docstring(constant.doc) | indent(width=4) }}
    {{ constant.name }} = {{ constant.value }}
{%- endfor -%}

{%- for signal in cls.signals %}

    {{ gen_docstring(signal.doc) | indent(width=4) }}
    # Signal {{ signal.name }}
{%- endfor -%}

{%- for member in cls.members %}

    @property
    def {{ member.name }}(self):
        {{ gen_docstring(member.doc) | indent(width=8) }}
        pass

    @{{ member.name }}.setter
    def {{ member.name }}(self, value):
        gd_propname = godot_string_from_pyobj({{ member.getter}})
        ret = godot_variant_alloc()
        lib.godot_variant_new_nil(ret)
        args = ffi.new("void*[]", [self._gd_ptr, gd_propname])
        lib.godot_method_bind_ptrcall(
            cls._meth_get_property, cls._instance, args, ret
        )
        return variant_to_pyobj(ret)

{%- endfor -%}

{%- for method in cls.methods %}

    def {{ method.name }}({{ gen_call_args(method.args) }}):
        {{ gen_docstring(method.doc) | indent(width=8) }}
        pass
{%- endfor -%}

{%- if not cls.constants and not cls.signals and not cls.members and not cls.methods %}
    pass
{%- endif -%}

{% endfor %}

# Globals constants and singletons

{% for singleton in singletons %}
{{ singleton.name }} = {{ singleton.type }}(lib.godot_global_get_singleton(b'{{ singleton.name }}')
{%- endfor -%}

{% for constant in constants %}
{%- if constant.doc %}
{{ gen_docstring(constant.doc) }}
{%- endif %}
{{ constant.name }} = {{ constant.value }}
{%- endfor %}
'''
)


def fix_name(name):
    # Yep ! Some names contain this...
    name = name.replace("/", "_")
    # Python keywords are invalid names
    return name + "_" if name in keyword.kwlist else name


def extract_list(doc, *path):
    sdoc = doc
    for parent in path[:-1]:
        sdoc = sdoc.get(parent)
        if not sdoc:
            return ()

    ssdoc = sdoc.get(path[-1])
    if ssdoc:
        return ssdoc if isinstance(ssdoc, (list, tuple)) else [ssdoc]

    else:
        return ()


def extract_constant_infos(doc):
    # TODO: handle enum
    return {
        "name": fix_name(doc["@name"]), "doc": doc.get("#text"), "value": doc["@value"]
    }


def extract_signal_infos(doc):
    args = sorted(extract_list(doc, "argument"), key=lambda x: int(x["@index"]))
    return {
        "name": fix_name(doc["@name"]),
        "doc": doc.get("description"),
        "args": [
            {
                "name": fix_name(x["@name"]),
                "type": x["@type"],
                "default": x.get("@default"),
            }
            for x in args
        ],
    }


def extract_member_infos(doc):
    # TODO: handle enum
    return {
        "name": fix_name(doc["@name"]),
        "doc": doc.get("#text"),
        "type": doc["@type"],
        "setter": doc["@setter"],
        "getter": doc["@getter"],
    }


def extract_method_infos(doc):
    args = sorted(extract_list(doc, "argument"), key=lambda x: int(x["@index"]))
    return {
        "name": fix_name(doc["@name"]),
        "doc": doc.get("description") or doc.get("brief_description"),
        "args": [
            {
                "name": fix_name(x["@name"]),
                "type": x["@type"],
                "default": x.get("@default"),
            }
            for x in args
        ],
        "vaargs": doc.get("@qualifiers") == "vaargs",
    }


def extract_class_infos(doc):
    return {
        "name": fix_name(doc["@name"]),
        "doc": doc.get("description") or doc.get("brief_description"),
        "constants": [
            extract_constant_infos(mdoc)
            for mdoc in extract_list(doc, "constants", "constant")
        ],
        "signals": [
            extract_signal_infos(mdoc)
            for mdoc in extract_list(doc, "signals", "signal")
        ],
        "members": [
            extract_member_infos(mdoc)
            for mdoc in extract_list(doc, "members", "member")
        ],
        "methods": [
            extract_method_infos(mdoc)
            for mdoc in extract_list(doc, "methods", "method")
        ],
    }


def extract_module_infos(global_doc, classes_doc):
    return {
        "godot_api_version": global_doc["@version"],
        "classes": [extract_class_infos(x) for x in classes_doc],
        "singletons": [
            {"name": fix_name(x["@name"]), "type": x["@type"]}
            for x in extract_list(global_doc, "members", "member")
        ],
        "constants": [
            extract_constant_infos(x)
            for x in extract_list(global_doc, "constants", "constant")
        ],
    }


def generate_godot_bindings(output, docs_path, pretty=True, no_docstring=False):
    docs_path = pathlib.Path(docs_path)
    assert docs_path.exists()
    output = pathlib.Path(output)

    print("Generating bindings...")

    with open(docs_path / "@GlobalScope.xml") as fd:
        global_doc = xmltodict.parse(fd.read())["class"]

    def iter_classes_doc():
        for doc_path in docs_path.iterdir():
            with open(doc_path) as fd:
                doc = xmltodict.parse(fd.read())["class"]
                if doc["@name"].startswith("@") or doc["@category"] == "Built-In Types":
                    continue

                yield doc

    infos = extract_module_infos(global_doc, iter_classes_doc())
    rendered = TEMPLATE.render(infos, NO_DOCSTRINGS=no_docstring)
    with open(output, "w") as fd:
        fd.write(rendered)

    if pretty:
        print("Prettifying...")
        black.format_file_in_place(output, 80, False)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="")
    parser.add_argument("godot_docs", help="Path to Godot documentation")
    parser.add_argument("--output", "-o", default="godot_bindings.gen.py")
    parser.add_argument("--pretty", "-p", action="store_true")
    parser.add_argument("--no-docstring", "-N", action="store_true")
    args = parser.parse_args()
    generate_godot_bindings(
        args.output, args.godot_docs, args.pretty, args.no_docstring
    )
